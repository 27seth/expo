package expo.modules.backgroundtask

import android.content.Context
import android.os.Build
import android.util.Log
import androidx.work.Constraints
import androidx.work.NetworkType
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import expo.modules.kotlin.exception.CodedException
import expo.modules.kotlin.functions.Coroutine
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.Runnable
import kotlinx.coroutines.suspendCancellableCoroutine
import java.time.Duration
import java.util.UUID
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class MissingAppContextException : CodedException(message = "App Context not available.")

const val PERFORM_WORK_EVENT_NAME = "BackgroundTask.peformWork"

// Unique identifier (generated by us) to identify the worker
const val WORKER_IDENTIFIER_VALUE = "75d281a2-f7e0-4fdc-816b-1915866e154e"

class BackgroundTaskModule : Module() {
  companion object {
    private const val MODULE_NAME: String = "ExpoBackgroundTask"
    private val WORKER_IDENTIFIER: UUID = UUID.fromString(WORKER_IDENTIFIER_VALUE)
    private val TAG: String = BackgroundTaskModule::class.java.simpleName
  }

  private var _completableDeferred : CompletableDeferred<Boolean>? = null

  override fun definition() = ModuleDefinition {
    Name(MODULE_NAME)
    Events(PERFORM_WORK_EVENT_NAME)
    Constants("EVENT_NAME" to PERFORM_WORK_EVENT_NAME)

    OnCreate {
      Log.i(TAG, "Background Task Manager Module created - adding callback.")
      BackgroundTaskWork.setInvokeWorkFunction ( ::taskWorkCallback )
    }

    OnDestroy {
      Log.i(TAG, "Background Task Manager Module destroyed - removing callback.")
      BackgroundTaskWork.setInvokeWorkFunction(null)
    }

    AsyncFunction("startWorkerAsync") Coroutine { ->
      appContext.reactContext?.let { scheduleJob(it) } ?: throw MissingAppContextException()
    }

    AsyncFunction("stopWorkerAsync") Coroutine { ->
      appContext.reactContext?.let { cancelJob(it) } ?: throw MissingAppContextException()
    }

    AsyncFunction("isWorkerRunningAsync") Coroutine { ->
      return@Coroutine isWorkerRunning()
    }

    AsyncFunction("getStatusAsync") {
      return@AsyncFunction 2 // Always available on Android
    }

    AsyncFunction("workFinished") {
      if (_completableDeferred != null) {
        _completableDeferred?.complete(true)
        _completableDeferred = null
      }
    }
  }

  private fun taskWorkCallback(completableDeferred : CompletableDeferred<Boolean>) {
    Log.i(TAG, "Background Task Manager Module got callback, ready to notify JS.")
    _completableDeferred = completableDeferred
    sendEvent(PERFORM_WORK_EVENT_NAME)
  }

  private suspend fun isWorkerRunning(): Boolean {
    val workInfo = appContext.reactContext?.let { getWorkerInfo(it) }
    return workInfo?.state == WorkInfo.State.RUNNING ||
           workInfo?.state == WorkInfo.State.ENQUEUED
  }

  /**
   * Returns the worker info object from the WorkManager if the worker has been
   * registered, otherwise returns null
   */
  private suspend fun getWorkerInfo(context: Context): WorkInfo? {
    // Get work manager
    val workManager = WorkManager.getInstance(context)

    return suspendCancellableCoroutine<WorkInfo?> { continuation ->
      val workInfoFuture = workManager.getWorkInfoById(WORKER_IDENTIFIER)
      workInfoFuture.addListener(Runnable {
        try {
          // This blocks until the result is available
          val workInfo = workInfoFuture.get()
          continuation.resume(workInfo)
        } catch (e: Exception) {
          continuation.resumeWithException(e)
        }
      }, Executors.newSingleThreadExecutor())

      continuation.invokeOnCancellation {
        // Clean up if coroutine gets cancelled
        workInfoFuture.cancel(true)
      }
    }
  }

  /**
   * Cancels the worker. The caller should check wether or not the worker is running, allthough
   * it is not a big issue calling cancel when the worker is not running.
   */
  private suspend fun cancelJob(context: Context) : Boolean {
    Log.i(TAG, "Cancelling worker with identifier $WORKER_IDENTIFIER")

    // Stop our main worker
    val workManager = WorkManager.getInstance(context)
    return suspendCancellableCoroutine<Boolean> { continuation ->
      val operation = workManager.cancelWorkById(WORKER_IDENTIFIER)
      val future = operation.result
      future.addListener(Runnable {
        try {
          // This blocks until the result is available
          future.get()
          Log.i(TAG, "Worker cancelled successfully")
          continuation.resume(true)   // Worker is still running
        } catch (e: Exception) {
          Log.i(TAG, "Stopping worker failed with error " + e.message)
          continuation.resumeWithException(e)
        }
      }, Executors.newSingleThreadExecutor())

      continuation.invokeOnCancellation {
        // Clean up if coroutine gets cancelled
        Log.w(TAG, "Stopping worker was cancelled.")
        future.cancel(true)
      }
    }
  }

  /**
   * Schedules the worker. The caller should check wether or not the worker is running, allthough
   * it is not a big issue calling cancel when the worker is running.
   */
  private suspend fun scheduleJob(context: Context): Boolean {
    // Ensure we have the react context
    Log.i(TAG, "Enqueuing worker with identifier $WORKER_IDENTIFIER")

    // Create the work request
    val builder = PeriodicWorkRequestBuilder<BackgroundTaskWork>(
      repeatIntervalTimeUnit = TimeUnit.MINUTES,
      repeatInterval = 15
    )
      .setId(WORKER_IDENTIFIER)
      .setConstraints(
        Constraints.Builder()
          .setRequiresBatteryNotLow(true)
          .setRequiredNetworkType(NetworkType.CONNECTED)
          .build()
      )

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      builder.setInitialDelay(Duration.ofSeconds(5))
    }

    // Create work request
    val workRequest = builder.build()

    // Get Work manager
    val workManager = WorkManager.getInstance(context)

    // Prune existing
    workManager.pruneWork()

    // Enqueue the work
    return suspendCancellableCoroutine { continuation ->
      val operation = workManager.enqueue(workRequest)
      val future = operation.result
      future.addListener(Runnable {
        try {
          // This blocks until the result is available
          future.get()
          // Operation succeeded
          Log.i(TAG, "Worker enqueued successfully")
          continuation.resume(true)
        } catch (e: Exception) {
          Log.e(TAG, "Worker failed to start with error " + e.message)
          continuation.resumeWithException(e)
        }
      }, Executors.newSingleThreadExecutor())

      continuation.invokeOnCancellation {
        // Clean up if coroutine gets cancelled
        Log.w(TAG, "Starting worker was cancelled")
        future.cancel(true)
      }
    }
  }
}

